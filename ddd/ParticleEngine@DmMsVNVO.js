const u=Object.freeze({CUBE:1,SPHERE:2}),H=`

${THREE.ShaderChunk.common}
${THREE.ShaderChunk.logdepthbuf_pars_vertex}

attribute vec3  customColor;
attribute float customOpacity;
attribute float customSize;
attribute float customAngle;
attribute float customVisible;  // float used as boolean (0 = false, 1 = true)
varying vec4  vColor;
varying float vAngle;

void main() {
	if ( customVisible > 0.5 ) vColor = vec4( customColor, customOpacity );
	else vColor = vec4(0.0, 0.0, 0.0, 0.0);

	vAngle = customAngle;

	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );     // scale particles as objects in 3D space
	gl_Position = projectionMatrix * mvPosition;
	${THREE.ShaderChunk.logdepthbuf_vertex}
}

`,R=`
${THREE.ShaderChunk.logdepthbuf_pars_fragment}
uniform sampler2D map;
varying vec4 vColor;
varying float vAngle;

void main() {
	gl_FragColor = vColor;

	float c = cos(vAngle);
	float s = sin(vAngle);
	vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,
	c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);  // rotate UV coordinates to rotate texture
	vec4 rotatedTexture = texture2D( map,  rotatedUV );
			// "gl_FragColor = vec4(1.0,1.0,1.0,1.0);    // sets an otherwise white particle texture to desired color
	gl_FragColor = gl_FragColor * rotatedTexture;    // sets an otherwise white particle texture to desired color
	${THREE.ShaderChunk.logdepthbuf_fragment}
}

`;function c(t,e){this.times=t||[],this.values=e||[]}c.prototype.lerp=function(t){let e=0,s=this.times.length;for(;e<s&&t>this.times[e];)e++;if(e==0)return this.values[0];if(e==s)return this.values[s-1];let l=(t-this.times[e-1])/(this.times[e]-this.times[e-1]);return this.values[0]instanceof THREE.Vector3?this.values[e-1].clone().lerp(this.values[e],l):this.values[e-1]+l*(this.values[e]-this.values[e-1])};function y(){this.position=new THREE.Vector3,this.velocity=new THREE.Vector3,this.acceleration=new THREE.Vector3,this.angle=0,this.angleVelocity=0,this.angleAcceleration=0,this.size=1,this.color=new THREE.Color,this.opacity=1,this.age=0,this.alive=0}y.prototype.update=function(t){if(this.position.add(this.velocity.clone().multiplyScalar(t)),this.velocity.add(this.acceleration.clone().multiplyScalar(t)),this.angle+=this.angleVelocity*.01745329251*t,this.angleVelocity+=this.angleAcceleration*.01745329251*t,this.age+=t,this.sizeTween.times.length>0&&(this.size=this.sizeTween.lerp(this.age)),this.colorTween.times.length>0){let e=this.colorTween.lerp(this.age);this.color=new THREE.Color().setHSL(e.x,e.y,e.z)}this.opacityTween.times.length>0&&(this.opacity=this.opacityTween.lerp(this.age))};function h(){this.positionStyle=u.CUBE,this.positionBase=new THREE.Vector3,this.positionSpread=new THREE.Vector3,this.positionRadius=0,this.velocityStyle=u.CUBE,this.velocityBase=new THREE.Vector3,this.velocitySpread=new THREE.Vector3,this.speedBase=0,this.speedSpread=0,this.accelerationBase=new THREE.Vector3,this.accelerationSpread=new THREE.Vector3,this.angleBase=0,this.angleSpread=0,this.angleVelocityBase=0,this.angleVelocitySpread=0,this.angleAccelerationBase=0,this.angleAccelerationSpread=0,this.sizeBase=0,this.sizeSpread=0,this.sizeTween=new c,this.colorBase=new THREE.Vector3(0,1,.5),this.colorSpread=new THREE.Vector3(0,0,0),this.colorTween=new c,this.opacityBase=1,this.opacitySpread=0,this.opacityTween=new c,this.blendStyle=THREE.NormalBlending,this.particleArray=[],this.particlesPerSecond=100,this.particleDeathAge=1,this.emitterAge=0,this.emitterAlive=!0,this.emitterDeathAge=60,this.particleCount=this.particlesPerSecond*Math.min(this.particleDeathAge,this.emitterDeathAge),this.particleGeometry=new THREE.BufferGeometry,this.particleTexture=null,this.particleMaterial=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:this.particleTexture}},vertexShader:H,fragmentShader:R,transparent:!0,alphaTest:.5,blending:THREE.NormalBlending,depthTest:!0,depthWrite:!0}),this.particleMesh=new THREE.Mesh(this.particleGeometry,this.particleMaterial),f(this.particleMesh),T(this.particleMesh.material)}h.prototype.setValues=function(t){if(t===void 0)return;this.sizeTween=new c,this.colorTween=new c,this.opacityTween=new c;for(let s in t)this[s]=t[s];y.prototype.sizeTween=this.sizeTween,y.prototype.colorTween=this.colorTween,y.prototype.opacityTween=this.opacityTween,this.emitterAge=0,this.emitterAlive=!0,this.particleCount=this.particlesPerSecond*Math.min(this.particleDeathAge,this.emitterDeathAge),this.particleArray=new Array(this.particleCount),this.particleGeometry=new THREE.BufferGeometry,this.particleMaterial=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:this.particleTexture}},vertexShader:H,fragmentShader:R,transparent:!0,alphaTest:.5,blending:THREE.NormalBlending,depthTest:!0,depthWrite:!0});const e=new THREE.BufferGeometry;e.setAttribute("position",new THREE.BufferAttribute(new Float32Array(this.particleCount*3),3)),e.setAttribute("customVisible",new THREE.BufferAttribute(new Float32Array(this.particleCount),1)),e.setAttribute("customAngle",new THREE.BufferAttribute(new Float32Array(this.particleCount),1)),e.setAttribute("customSize",new THREE.BufferAttribute(new Float32Array(this.particleCount),1)),e.setAttribute("customColor",new THREE.BufferAttribute(new Float32Array(this.particleCount*3),3)),e.setAttribute("customOpacity",new THREE.BufferAttribute(new Float32Array(this.particleCount),1)),e.attributes.position.setUsage(THREE.DynamicDrawUsage),e.attributes.customVisible.setUsage(THREE.DynamicDrawUsage),e.attributes.customAngle.setUsage(THREE.DynamicDrawUsage),e.attributes.customSize.setUsage(THREE.DynamicDrawUsage),e.attributes.customColor.setUsage(THREE.DynamicDrawUsage),e.attributes.customOpacity.setUsage(THREE.DynamicDrawUsage),this.particleGeometry=e,this.particleMesh=new THREE.Points(this.particleGeometry,this.particleMaterial),f(this.particleMesh),T(this.particleMesh.material)};h.prototype.randomValue=function(t,e){return t+e*(Math.random()-.5)};h.prototype.randomVector3=function(t,e){let s=new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5);return new THREE.Vector3().addVectors(t,new THREE.Vector3().multiplyVectors(e,s))};h.prototype.createParticle=function(){let t=new y;if(this.positionStyle==u.CUBE&&(t.position=this.randomVector3(this.positionBase,this.positionSpread)),this.positionStyle==u.SPHERE){let s=2*Math.random()-1,l=6.2832*Math.random(),d=Math.sqrt(1-s*s),E=new THREE.Vector3(d*Math.cos(l),d*Math.sin(l),s);t.position=new THREE.Vector3().addVectors(this.positionBase,E.multiplyScalar(this.positionRadius))}if(this.velocityStyle==u.CUBE&&(t.velocity=this.randomVector3(this.velocityBase,this.velocitySpread)),this.velocityStyle==u.SPHERE){let s=new THREE.Vector3().subVectors(t.position,this.positionBase),l=this.randomValue(this.speedBase,this.speedSpread);t.velocity=s.normalize().multiplyScalar(l)}t.acceleration=this.randomVector3(this.accelerationBase,this.accelerationSpread),t.angle=this.randomValue(this.angleBase,this.angleSpread),t.angleVelocity=this.randomValue(this.angleVelocityBase,this.angleVelocitySpread),t.angleAcceleration=this.randomValue(this.angleAccelerationBase,this.angleAccelerationSpread),t.size=this.randomValue(this.sizeBase,this.sizeSpread);let e=this.randomVector3(this.colorBase,this.colorSpread);return t.color=new THREE.Color().setHSL(e.x,e.y,e.z),t.opacity=this.randomValue(this.opacityBase,this.opacitySpread),t.age=0,t.alive=0,t};function f(t){t.dynamic=!0,t.sortParticles=!0,t.renderOrder=3,t.frustumCulled=!1}function T(t){t.transparent=!0,t.alphaTest=.5,t.blending=THREE.NormalBlending,t.depthTest=!1,t.depthWrite=!1}h.prototype.initialize=function(){const t=this.particleGeometry,e=t.attributes.position,s=t.attributes.customVisible,l=t.attributes.customColor,d=t.attributes.customOpacity,E=t.attributes.customSize,V=t.attributes.customAngle;for(let a=0;a<this.particleCount;a++)this.particleArray[a]=this.createParticle(),e.array[a*3+0]=this.particleArray[a].position.x,e.array[a*3+1]=this.particleArray[a].position.y,e.array[a*3+2]=this.particleArray[a].position.z,s.array[a]=this.particleArray[a].alive,l.array[a*3+0]=this.particleArray[a].color.r,l.array[a*3+1]=this.particleArray[a].color.g,l.array[a*3+2]=this.particleArray[a].color.b,d.array[a]=this.particleArray[a].opacity,E.array[a]=this.particleArray[a].size,V.array[a]=this.particleArray[a].angle;this.particleMaterial.blending=this.blendStyle,this.particleMaterial.depthTest=this.blendStyle==THREE.NormalBlending,this.particleMaterial.depthWrite=!1,this.particleMesh=new THREE.Points(this.particleGeometry,this.particleMaterial),f(this.particleMesh),T(this.particleMesh.material);const i=this;let m=[];this.particleMesh.user.updaters.calculate_particles=function(a){m.length=0;const p=i.particleMesh.geometry,n=p.attributes.position,w=p.attributes.customVisible,g=p.attributes.customColor,v=p.attributes.customOpacity,S=p.attributes.customSize,b=p.attributes.customAngle;for(let r=0;r<i.particleCount;r++)i.particleArray[r].alive&&(i.particleArray[r].update(a),i.particleArray[r].age>i.particleDeathAge&&(i.particleArray[r].alive=0,m.push(r)),n.array[r*3+0]=i.particleArray[r].position.x,n.array[r*3+1]=i.particleArray[r].position.y,n.array[r*3+2]=i.particleArray[r].position.z,w.array[r]=i.particleArray[r].alive,g.array[r*3+0]=i.particleArray[r].color.r,g.array[r*3+1]=i.particleArray[r].color.g,g.array[r*3+2]=i.particleArray[r].color.b,v.array[r]=i.particleArray[r].opacity,S.array[r]=i.particleArray[r].size,b.array[r]=i.particleArray[r].angle);if(i.emitterAlive){if(i.emitterAge<i.particleDeathAge){let r=Math.round(i.particlesPerSecond*(i.emitterAge+0)),o=Math.round(i.particlesPerSecond*(i.emitterAge+a));o>i.particleCount&&(o=i.particleCount);for(let A=r;A<o;A++)i.particleArray[A].alive=1}for(let r=0;r<m.length;r++){let o=m[r];i.particleArray[o]=i.createParticle(),i.particleArray[o].alive=1,n.array[o*3+0]=i.particleArray[o].position.x,n.array[o*3+1]=i.particleArray[o].position.y,n.array[o*3+2]=i.particleArray[o].position.z}n.needsUpdate=!0,w.needsUpdate=!0,g.needsUpdate=!0,v.needsUpdate=!0,S.needsUpdate=!0,b.needsUpdate=!0,i.emitterAge+=a,i.emitterAge>i.emitterDeathAge&&(i.emitterAlive=!1)}}};h.prototype.getObject=function(){return this.particleMesh};h.prototype.destroy=function(){};export{y as Particle,h as ParticleEngine,c as Tween,u as Type};
