import{aD as Sn,H as Q,au as ve,F as se,R as wn,ab as mn,aG as In,p as Ue,aF as Ne}from"./ddd@DwDq534T.js";import{u as V}from"./fflate.module@Do-qMP1X.js";class Bn extends Sn{constructor(k){super(k),this.type=Q}parse(k){const Ae=Math.pow(2.7182818,2.2);function Oe(e,n){let t=0;for(let l=0;l<65536;++l)(l==0||e[l>>3]&1<<(l&7))&&(n[t++]=l);const o=t-1;for(;t<65536;)n[t++]=0;return o}function Te(e){for(let n=0;n<16384;n++)e[n]={},e[n].len=0,e[n].lit=0,e[n].p=null}const F={l:0,c:0,lc:0};function ae(e,n,t,o,l){for(;t<e;)n=n<<8|ge(o,l),t+=8;t-=e,F.l=n>>t&(1<<e)-1,F.c=n,F.lc=t}const X=new Array(59);function be(e){for(let t=0;t<=58;++t)X[t]=0;for(let t=0;t<65537;++t)X[e[t]]+=1;let n=0;for(let t=58;t>0;--t){const o=n+X[t]>>1;X[t]=n,n=o}for(let t=0;t<65537;++t){const o=e[t];o>0&&(e[t]=o|X[o]++<<6)}}function Re(e,n,t,o,l,r){const i=n;let a=0,u=0;for(;o<=l;o++){if(i.value-n.value>t)return!1;ae(6,a,u,e,i);const c=F.l;if(a=F.c,u=F.lc,r[o]=c,c==63){if(i.value-n.value>t)throw new Error("Something wrong with hufUnpackEncTable");ae(8,a,u,e,i);let s=F.l+6;if(a=F.c,u=F.lc,o+s>l+1)throw new Error("Something wrong with hufUnpackEncTable");for(;s--;)r[o++]=0;o--}else if(c>=59){let s=c-59+2;if(o+s>l+1)throw new Error("Something wrong with hufUnpackEncTable");for(;s--;)r[o++]=0;o--}}be(r)}function he(e){return e&63}function pe(e){return e>>6}function Me(e,n,t,o){for(;n<=t;n++){const l=pe(e[n]),r=he(e[n]);if(l>>r)throw new Error("Invalid table entry");if(r>14){const i=o[l>>r-14];if(i.len)throw new Error("Invalid table entry");if(i.lit++,i.p){const a=i.p;i.p=new Array(i.lit);for(let u=0;u<i.lit-1;++u)i.p[u]=a[u]}else i.p=new Array(1);i.p[i.lit-1]=n}else if(r){let i=0;for(let a=1<<14-r;a>0;a--){const u=o[(l<<14-r)+i];if(u.len||u.p)throw new Error("Invalid table entry");u.len=r,u.lit=n,i++}}}return!0}const B={c:0,lc:0};function ne(e,n,t,o){e=e<<8|ge(t,o),n+=8,B.c=e,B.lc=n}const d={c:0,lc:0};function te(e,n,t,o,l,r,i,a,u){if(e==n){o<8&&(ne(t,o,l,r),t=B.c,o=B.lc),o-=8;let c=t>>o;if(c=new Uint8Array([c])[0],a.value+c>u)return!1;const s=i[a.value-1];for(;c-- >0;)i[a.value++]=s}else if(a.value<u)i[a.value++]=e;else return!1;d.c=t,d.lc=o}function oe(e){return e&65535}function Ee(e){const n=oe(e);return n>32767?n-65536:n}const U={a:0,b:0};function Y(e,n){const t=Ee(e),l=Ee(n),r=t+(l&1)+(l>>1),i=r,a=r-l;U.a=i,U.b=a}function W(e,n){const t=oe(e),o=oe(n),l=t-(o>>1)&65535,r=o+l-32768&65535;U.a=r,U.b=l}function xe(e,n,t,o,l,r,i){const a=i<16384,u=t>l?l:t;let c=1,s,h;for(;c<=u;)c<<=1;for(c>>=1,s=c,c>>=1;c>=1;){h=0;const w=h+r*(l-s),p=r*c,I=r*s,E=o*c,m=o*s;let f,C,N,R;for(;h<=w;h+=I){let v=h;const g=h+o*(t-s);for(;v<=g;v+=m){const A=v+E,D=v+p,O=D+E;a?(Y(e[v+n],e[D+n]),f=U.a,N=U.b,Y(e[A+n],e[O+n]),C=U.a,R=U.b,Y(f,C),e[v+n]=U.a,e[A+n]=U.b,Y(N,R),e[D+n]=U.a,e[O+n]=U.b):(W(e[v+n],e[D+n]),f=U.a,N=U.b,W(e[A+n],e[O+n]),C=U.a,R=U.b,W(f,C),e[v+n]=U.a,e[A+n]=U.b,W(N,R),e[D+n]=U.a,e[O+n]=U.b)}if(t&c){const A=v+p;a?Y(e[v+n],e[A+n]):W(e[v+n],e[A+n]),f=U.a,e[A+n]=U.b,e[v+n]=f}}if(l&c){let v=h;const g=h+o*(t-s);for(;v<=g;v+=m){const A=v+E;a?Y(e[v+n],e[A+n]):W(e[v+n],e[A+n]),f=U.a,e[A+n]=U.b,e[v+n]=f}}s=c,c>>=1}return h}function De(e,n,t,o,l,r,i,a,u){let c=0,s=0;const h=i,w=Math.trunc(o.value+(l+7)/8);for(;o.value<w;)for(ne(c,s,t,o),c=B.c,s=B.lc;s>=14;){const I=c>>s-14&16383,E=n[I];if(E.len)s-=E.len,te(E.lit,r,c,s,t,o,a,u,h),c=d.c,s=d.lc;else{if(!E.p)throw new Error("hufDecode issues");let m;for(m=0;m<E.lit;m++){const f=he(e[E.p[m]]);for(;s<f&&o.value<w;)ne(c,s,t,o),c=B.c,s=B.lc;if(s>=f&&pe(e[E.p[m]])==(c>>s-f&(1<<f)-1)){s-=f,te(E.p[m],r,c,s,t,o,a,u,h),c=d.c,s=d.lc;break}}if(m==E.lit)throw new Error("hufDecode issues")}}const p=8-l&7;for(c>>=p,s-=p;s>0;){const I=n[c<<14-s&16383];if(I.len)s-=I.len,te(I.lit,r,c,s,t,o,a,u,h),c=d.c,s=d.lc;else throw new Error("hufDecode issues")}return!0}function Se(e,n,t,o,l,r){const i={value:0},a=t.value,u=x(n,t),c=x(n,t);t.value+=4;const s=x(n,t);if(t.value+=4,u<0||u>=65537||c<0||c>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const h=new Array(65537),w=new Array(16384);Te(w);const p=o-(t.value-a);if(Re(e,t,p,u,c,h),s>8*(o-(t.value-a)))throw new Error("Something wrong with hufUncompress");Me(h,u,c,w),De(h,w,e,t,s,c,r,l,i)}function Le(e,n,t){for(let o=0;o<t;++o)n[o]=e[n[o]]}function we(e){for(let n=1;n<e.length;n++){const t=e[n-1]+e[n]-128;e[n]=t}}function me(e,n){let t=0,o=Math.floor((e.length+1)/2),l=0;const r=e.length-1;for(;!(l>r||(n[l++]=e[t++],l>r));)n[l++]=e[o++]}function Ie(e){let n=e.byteLength;const t=new Array;let o=0;const l=new DataView(e);for(;n>0;){const r=l.getInt8(o++);if(r<0){const i=-r;n-=i+1;for(let a=0;a<i;a++)t.push(l.getUint8(o++))}else{const i=r;n-=2;const a=l.getUint8(o++);for(let u=0;u<i+1;u++)t.push(a)}}return t}function ke(e,n,t,o,l,r){let i=new DataView(r.buffer);const a=t[e.idx[0]].width,u=t[e.idx[0]].height,c=3,s=Math.floor(a/8),h=Math.ceil(a/8),w=Math.ceil(u/8),p=a-(h-1)*8,I=u-(w-1)*8,E={value:0},m=new Array(c),f=new Array(c),C=new Array(c),N=new Array(c),R=new Array(c);for(let g=0;g<c;++g)R[g]=n[e.idx[g]],m[g]=g<1?0:m[g-1]+h*w,f[g]=new Float32Array(64),C[g]=new Uint16Array(64),N[g]=new Uint16Array(h*64);for(let g=0;g<w;++g){let A=8;g==w-1&&(A=I);let D=8;for(let y=0;y<h;++y){y==h-1&&(D=p);for(let _=0;_<c;++_)C[_].fill(0),C[_][0]=l[m[_]++],Fe(E,o,C[_]),Ze(C[_],f[_]),Be(f[_]);de(f);for(let _=0;_<c;++_)Pe(f[_],N[_],y*64)}let O=0;for(let y=0;y<c;++y){const _=t[e.idx[y]].type;for(let Z=8*g;Z<8*g+A;++Z){O=R[y][Z];for(let q=0;q<s;++q){const L=q*64+(Z&7)*8;i.setUint16(O+0*2*_,N[y][L+0],!0),i.setUint16(O+1*2*_,N[y][L+1],!0),i.setUint16(O+2*2*_,N[y][L+2],!0),i.setUint16(O+3*2*_,N[y][L+3],!0),i.setUint16(O+4*2*_,N[y][L+4],!0),i.setUint16(O+5*2*_,N[y][L+5],!0),i.setUint16(O+6*2*_,N[y][L+6],!0),i.setUint16(O+7*2*_,N[y][L+7],!0),O+=8*2*_}}if(s!=h)for(let Z=8*g;Z<8*g+A;++Z){const q=R[y][Z]+8*s*2*_,L=s*64+(Z&7)*8;for(let J=0;J<D;++J)i.setUint16(q+J*2*_,N[y][L+J],!0)}}}const v=new Uint16Array(a);i=new DataView(r.buffer);for(let g=0;g<c;++g){t[e.idx[g]].decoded=!0;const A=t[e.idx[g]].type;if(t[g].type==2)for(let D=0;D<u;++D){const O=R[g][D];for(let y=0;y<a;++y)v[y]=i.getUint16(O+y*2*A,!0);for(let y=0;y<a;++y)i.setFloat32(O+y*2*A,S(v[y]),!0)}}}function Fe(e,n,t){let o,l=1;for(;l<64;)o=n[e.value],o==65280?l=64:o>>8==255?l+=o&255:(t[l]=o,l++),e.value++}function Ze(e,n){n[0]=S(e[0]),n[1]=S(e[1]),n[2]=S(e[5]),n[3]=S(e[6]),n[4]=S(e[14]),n[5]=S(e[15]),n[6]=S(e[27]),n[7]=S(e[28]),n[8]=S(e[2]),n[9]=S(e[4]),n[10]=S(e[7]),n[11]=S(e[13]),n[12]=S(e[16]),n[13]=S(e[26]),n[14]=S(e[29]),n[15]=S(e[42]),n[16]=S(e[3]),n[17]=S(e[8]),n[18]=S(e[12]),n[19]=S(e[17]),n[20]=S(e[25]),n[21]=S(e[30]),n[22]=S(e[41]),n[23]=S(e[43]),n[24]=S(e[9]),n[25]=S(e[11]),n[26]=S(e[18]),n[27]=S(e[24]),n[28]=S(e[31]),n[29]=S(e[40]),n[30]=S(e[44]),n[31]=S(e[53]),n[32]=S(e[10]),n[33]=S(e[19]),n[34]=S(e[23]),n[35]=S(e[32]),n[36]=S(e[39]),n[37]=S(e[45]),n[38]=S(e[52]),n[39]=S(e[54]),n[40]=S(e[20]),n[41]=S(e[22]),n[42]=S(e[33]),n[43]=S(e[38]),n[44]=S(e[46]),n[45]=S(e[51]),n[46]=S(e[55]),n[47]=S(e[60]),n[48]=S(e[21]),n[49]=S(e[34]),n[50]=S(e[37]),n[51]=S(e[47]),n[52]=S(e[50]),n[53]=S(e[56]),n[54]=S(e[59]),n[55]=S(e[61]),n[56]=S(e[35]),n[57]=S(e[36]),n[58]=S(e[48]),n[59]=S(e[49]),n[60]=S(e[57]),n[61]=S(e[58]),n[62]=S(e[62]),n[63]=S(e[63])}function Be(e){const n=.5*Math.cos(.7853975),t=.5*Math.cos(3.14159/16),o=.5*Math.cos(3.14159/8),l=.5*Math.cos(3*3.14159/16),r=.5*Math.cos(5*3.14159/16),i=.5*Math.cos(3*3.14159/8),a=.5*Math.cos(7*3.14159/16),u=new Array(4),c=new Array(4),s=new Array(4),h=new Array(4);for(let w=0;w<8;++w){const p=w*8;u[0]=o*e[p+2],u[1]=i*e[p+2],u[2]=o*e[p+6],u[3]=i*e[p+6],c[0]=t*e[p+1]+l*e[p+3]+r*e[p+5]+a*e[p+7],c[1]=l*e[p+1]-a*e[p+3]-t*e[p+5]-r*e[p+7],c[2]=r*e[p+1]-t*e[p+3]+a*e[p+5]+l*e[p+7],c[3]=a*e[p+1]-r*e[p+3]+l*e[p+5]-t*e[p+7],s[0]=n*(e[p+0]+e[p+4]),s[3]=n*(e[p+0]-e[p+4]),s[1]=u[0]+u[3],s[2]=u[1]-u[2],h[0]=s[0]+s[1],h[1]=s[3]+s[2],h[2]=s[3]-s[2],h[3]=s[0]-s[1],e[p+0]=h[0]+c[0],e[p+1]=h[1]+c[1],e[p+2]=h[2]+c[2],e[p+3]=h[3]+c[3],e[p+4]=h[3]-c[3],e[p+5]=h[2]-c[2],e[p+6]=h[1]-c[1],e[p+7]=h[0]-c[0]}for(let w=0;w<8;++w)u[0]=o*e[16+w],u[1]=i*e[16+w],u[2]=o*e[48+w],u[3]=i*e[48+w],c[0]=t*e[8+w]+l*e[24+w]+r*e[40+w]+a*e[56+w],c[1]=l*e[8+w]-a*e[24+w]-t*e[40+w]-r*e[56+w],c[2]=r*e[8+w]-t*e[24+w]+a*e[40+w]+l*e[56+w],c[3]=a*e[8+w]-r*e[24+w]+l*e[40+w]-t*e[56+w],s[0]=n*(e[w]+e[32+w]),s[3]=n*(e[w]-e[32+w]),s[1]=u[0]+u[3],s[2]=u[1]-u[2],h[0]=s[0]+s[1],h[1]=s[3]+s[2],h[2]=s[3]-s[2],h[3]=s[0]-s[1],e[0+w]=h[0]+c[0],e[8+w]=h[1]+c[1],e[16+w]=h[2]+c[2],e[24+w]=h[3]+c[3],e[32+w]=h[3]-c[3],e[40+w]=h[2]-c[2],e[48+w]=h[1]-c[1],e[56+w]=h[0]-c[0]}function de(e){for(let n=0;n<64;++n){const t=e[0][n],o=e[1][n],l=e[2][n];e[0][n]=t+1.5747*l,e[1][n]=t-.1873*o-.4682*l,e[2][n]=t+1.8556*o}}function Pe(e,n,t){for(let o=0;o<64;++o)n[t+o]=Ne.toHalfFloat(He(e[o]))}function He(e){return e<=1?Math.sign(e)*Math.pow(Math.abs(e),2.2):Math.sign(e)*Math.pow(Ae,Math.abs(e)-1)}function re(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function ze(e){const n=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),t=new Uint8Array(Ie(n)),o=new Uint8Array(t.length);return we(t),me(t,o),new DataView(o.buffer)}function le(e){const n=e.array.slice(e.offset.value,e.offset.value+e.size),t=V(n),o=new Uint8Array(t.length);return we(t),me(t,o),new DataView(o.buffer)}function Ye(e){const n=e.viewer,t={value:e.offset.value},o=new Uint16Array(e.columns*e.lines*(e.inputChannels.length*e.type)),l=new Uint8Array(8192);let r=0;const i=new Array(e.inputChannels.length);for(let I=0,E=e.inputChannels.length;I<E;I++)i[I]={},i[I].start=r,i[I].end=i[I].start,i[I].nx=e.columns,i[I].ny=e.lines,i[I].size=e.type,r+=i[I].nx*i[I].ny*i[I].size;const a=K(n,t),u=K(n,t);if(u>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(a<=u)for(let I=0;I<u-a+1;I++)l[I+a]=P(n,t);const c=new Uint16Array(65536),s=Oe(l,c),h=x(n,t);Se(e.array,n,t,h,o,r);for(let I=0;I<e.inputChannels.length;++I){const E=i[I];for(let m=0;m<i[I].size;++m)xe(o,E.start+m,E.nx,E.size,E.ny,E.nx*E.size,s)}Le(c,o,r);let w=0;const p=new Uint8Array(o.buffer.byteLength);for(let I=0;I<e.lines;I++)for(let E=0;E<e.inputChannels.length;E++){const m=i[E],f=m.nx*m.size,C=new Uint8Array(o.buffer,m.end*2,f*2);p.set(C,w),w+=f*2,m.end+=f}return new DataView(p.buffer)}function We(e){const n=e.array.slice(e.offset.value,e.offset.value+e.size),t=V(n),o=e.inputChannels.length*e.lines*e.columns*e.totalBytes,l=new ArrayBuffer(o),r=new DataView(l);let i=0,a=0;const u=new Array(4);for(let c=0;c<e.lines;c++)for(let s=0;s<e.inputChannels.length;s++){let h=0;switch(e.inputChannels[s].pixelType){case 1:u[0]=i,u[1]=u[0]+e.columns,i=u[1]+e.columns;for(let p=0;p<e.columns;++p){const I=t[u[0]++]<<8|t[u[1]++];h+=I,r.setUint16(a,h,!0),a+=2}break;case 2:u[0]=i,u[1]=u[0]+e.columns,u[2]=u[1]+e.columns,i=u[2]+e.columns;for(let p=0;p<e.columns;++p){const I=t[u[0]++]<<24|t[u[1]++]<<16|t[u[2]++]<<8;h+=I,r.setUint32(a,h,!0),a+=4}break}}return r}function fe(e){const n=e.viewer,t={value:e.offset.value},o=new Uint8Array(e.columns*e.lines*(e.inputChannels.length*e.type*2)),l={version:b(n,t),unknownUncompressedSize:b(n,t),unknownCompressedSize:b(n,t),acCompressedSize:b(n,t),dcCompressedSize:b(n,t),rleCompressedSize:b(n,t),rleUncompressedSize:b(n,t),rleRawSize:b(n,t),totalAcUncompressedCount:b(n,t),totalDcUncompressedCount:b(n,t),acCompression:b(n,t)};if(l.version<2)throw new Error("EXRLoader.parse: "+z.compression+" version "+l.version+" is unsupported");const r=new Array;let i=K(n,t)-2;for(;i>0;){const E=$(n.buffer,t),m=P(n,t),f=m>>2&3,C=(m>>4)-1,N=new Int8Array([C])[0],R=P(n,t);r.push({name:E,index:N,type:R,compression:f}),i-=E.length+3}const a=z.channels,u=new Array(e.inputChannels.length);for(let E=0;E<e.inputChannels.length;++E){const m=u[E]={},f=a[E];m.name=f.name,m.compression=0,m.decoded=!1,m.type=f.pixelType,m.pLinear=f.pLinear,m.width=e.columns,m.height=e.lines}const c={idx:new Array(3)};for(let E=0;E<e.inputChannels.length;++E){const m=u[E];for(let f=0;f<r.length;++f){const C=r[f];m.name==C.name&&(m.compression=C.compression,C.index>=0&&(c.idx[C.index]=E),m.offset=E)}}let s,h,w;if(l.acCompressedSize>0)switch(l.acCompression){case 0:s=new Uint16Array(l.totalAcUncompressedCount),Se(e.array,n,t,l.acCompressedSize,s,l.totalAcUncompressedCount);break;case 1:const E=e.array.slice(t.value,t.value+l.totalAcUncompressedCount),m=V(E);s=new Uint16Array(m.buffer),t.value+=l.totalAcUncompressedCount;break}if(l.dcCompressedSize>0){const E={array:e.array,offset:t,size:l.dcCompressedSize};h=new Uint16Array(le(E).buffer),t.value+=l.dcCompressedSize}if(l.rleRawSize>0){const E=e.array.slice(t.value,t.value+l.rleCompressedSize),m=V(E);w=Ie(m.buffer),t.value+=l.rleCompressedSize}let p=0;const I=new Array(u.length);for(let E=0;E<I.length;++E)I[E]=new Array;for(let E=0;E<e.lines;++E)for(let m=0;m<u.length;++m)I[m].push(p),p+=u[m].width*e.type*2;ke(c,I,u,s,h,o);for(let E=0;E<u.length;++E){const m=u[E];if(!m.decoded)switch(m.compression){case 2:let f=0,C=0;for(let N=0;N<e.lines;++N){let R=I[E][f];for(let v=0;v<m.width;++v){for(let g=0;g<2*m.type;++g)o[R++]=w[C+g*m.width*m.height];C++}f++}break;case 1:default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(o.buffer)}function $(e,n){const t=new Uint8Array(e);let o=0;for(;t[n.value+o]!=0;)o+=1;const l=new TextDecoder().decode(t.slice(n.value,n.value+o));return n.value=n.value+o+1,l}function Ge(e,n,t){const o=new TextDecoder().decode(new Uint8Array(e).slice(n.value,n.value+t));return n.value=n.value+t,o}function Xe(e,n){const t=M(e,n),o=x(e,n);return[t,o]}function Ke(e,n){const t=x(e,n),o=x(e,n);return[t,o]}function M(e,n){const t=e.getInt32(n.value,!0);return n.value=n.value+4,t}function x(e,n){const t=e.getUint32(n.value,!0);return n.value=n.value+4,t}function ge(e,n){const t=e[n.value];return n.value=n.value+1,t}function P(e,n){const t=e.getUint8(n.value);return n.value=n.value+1,t}const b=function(e,n){let t;return"getBigInt64"in DataView.prototype?t=Number(e.getBigInt64(n.value,!0)):t=e.getUint32(n.value+4,!0)+Number(e.getUint32(n.value,!0)<<32),n.value+=8,t};function T(e,n){const t=e.getFloat32(n.value,!0);return n.value+=4,t}function qe(e,n){return Ne.toHalfFloat(T(e,n))}function S(e){const n=(e&31744)>>10,t=e&1023;return(e>>15?-1:1)*(n?n===31?t?NaN:1/0:Math.pow(2,n-15)*(1+t/1024):6103515625e-14*(t/1024))}function K(e,n){const t=e.getUint16(n.value,!0);return n.value+=2,t}function $e(e,n){return S(K(e,n))}function Je(e,n,t,o){const l=t.value,r=[];for(;t.value<l+o-1;){const i=$(n,t),a=M(e,t),u=P(e,t);t.value+=3;const c=M(e,t),s=M(e,t);r.push({name:i,pixelType:a,pLinear:u,xSampling:c,ySampling:s})}return t.value+=1,r}function Qe(e,n){const t=T(e,n),o=T(e,n),l=T(e,n),r=T(e,n),i=T(e,n),a=T(e,n),u=T(e,n),c=T(e,n);return{redX:t,redY:o,greenX:l,greenY:r,blueX:i,blueY:a,whiteX:u,whiteY:c}}function Ve(e,n){const t=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],o=P(e,n);return t[o]}function je(e,n){const t=M(e,n),o=M(e,n),l=M(e,n),r=M(e,n);return{xMin:t,yMin:o,xMax:l,yMax:r}}function en(e,n){const t=["INCREASING_Y","DECREASING_Y","RANDOM_Y"],o=P(e,n);return t[o]}function nn(e,n){const t=["ENVMAP_LATLONG","ENVMAP_CUBE"],o=P(e,n);return t[o]}function tn(e,n){const t=["ONE_LEVEL","MIPMAP_LEVELS","RIPMAP_LEVELS"],o=["ROUND_DOWN","ROUND_UP"],l=x(e,n),r=x(e,n),i=P(e,n);return{xSize:l,ySize:r,levelMode:t[i&15],roundingMode:o[i>>4]}}function on(e,n){const t=T(e,n),o=T(e,n);return[t,o]}function rn(e,n){const t=T(e,n),o=T(e,n),l=T(e,n);return[t,o,l]}function ln(e,n,t,o,l){if(o==="string"||o==="stringvector"||o==="iccProfile")return Ge(n,t,l);if(o==="chlist")return Je(e,n,t,l);if(o==="chromaticities")return Qe(e,t);if(o==="compression")return Ve(e,t);if(o==="box2i")return je(e,t);if(o==="envmap")return nn(e,t);if(o==="tiledesc")return tn(e,t);if(o==="lineOrder")return en(e,t);if(o==="float")return T(e,t);if(o==="v2f")return on(e,t);if(o==="v3f")return rn(e,t);if(o==="int")return M(e,t);if(o==="rational")return Xe(e,t);if(o==="timecode")return Ke(e,t);if(o==="preview")return t.value+=l,"skipped";t.value+=l}function sn(e,n){const t=Math.log2(e);return n=="ROUND_DOWN"?Math.floor(t):Math.ceil(t)}function cn(e,n,t){let o=0;switch(e.levelMode){case"ONE_LEVEL":o=1;break;case"MIPMAP_LEVELS":o=sn(Math.max(n,t),e.roundingMode)+1;break;case"RIPMAP_LEVELS":throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")}return o}function ye(e,n,t,o){const l=new Array(e);for(let r=0;r<e;r++){const i=1<<r;let a=n/i|0;o=="ROUND_UP"&&a*i<n&&(a+=1);const u=Math.max(a,1);l[r]=(u+t-1)/t|0}return l}function un(){const e=this,n=e.offset,t={value:0};for(let o=0;o<e.tileCount;o++){const l=M(e.viewer,n),r=M(e.viewer,n);n.value+=8,e.size=x(e.viewer,n);const i=l*e.blockWidth,a=r*e.blockHeight;e.columns=i+e.blockWidth>e.width?e.width-i:e.blockWidth,e.lines=a+e.blockHeight>e.height?e.height-a:e.blockHeight;const u=e.columns*e.totalBytes,s=e.size<e.lines*u?e.uncompress(e):re(e);n.value+=e.size;for(let h=0;h<e.lines;h++){const w=h*e.columns*e.totalBytes;for(let p=0;p<e.inputChannels.length;p++){const I=z.channels[p].name,E=e.channelByteOffsets[I]*e.columns,m=e.decodeChannels[I];if(m===void 0)continue;t.value=w+E;const f=(e.height-(1+a+h))*e.outLineWidth;for(let C=0;C<e.columns;C++){const N=f+(C+i)*e.outputChannels+m;e.byteArray[N]=e.getter(s,t)}}}}}function an(){const e=this,n=e.offset,t={value:0};for(let o=0;o<e.height/e.blockHeight;o++){const l=M(e.viewer,n)-z.dataWindow.yMin;e.size=x(e.viewer,n),e.lines=l+e.blockHeight>e.height?e.height-l:e.blockHeight;const r=e.columns*e.totalBytes,a=e.size<e.lines*r?e.uncompress(e):re(e);n.value+=e.size;for(let u=0;u<e.blockHeight;u++){const c=o*e.blockHeight,s=u+e.scanOrder(c);if(s>=e.height)continue;const h=u*r,w=(e.height-1-s)*e.outLineWidth;for(let p=0;p<e.inputChannels.length;p++){const I=z.channels[p].name,E=e.channelByteOffsets[I]*e.columns,m=e.decodeChannels[I];if(m!==void 0){t.value=h+E;for(let f=0;f<e.columns;f++){const C=w+f*e.outputChannels+m;e.byteArray[C]=e.getter(a,t)}}}}}}function hn(e,n,t){const o={};if(e.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");o.version=e.getUint8(4);const l=e.getUint8(5);o.spec={singleTile:!!(l&2),longName:!!(l&4),deepFormat:!!(l&8),multiPart:!!(l&16)},t.value=8;let r=!0;for(;r;){const i=$(n,t);if(i==0)r=!1;else{const a=$(n,t),u=x(e,t),c=ln(e,n,t,a,u);c===void 0?console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${a}'.`):o[i]=c}}if(l&-7)throw console.error("THREE.EXRHeader:",o),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return o}function pn(e,n,t,o,l){const r={size:0,viewer:n,array:t,offset:o,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,inputChannels:e.channels,channelByteOffsets:{},scanOrder:null,totalBytes:null,columns:null,lines:null,type:null,uncompress:null,getter:null,format:null,colorSpace:ve};switch(e.compression){case"NO_COMPRESSION":r.blockHeight=1,r.uncompress=re;break;case"RLE_COMPRESSION":r.blockHeight=1,r.uncompress=ze;break;case"ZIPS_COMPRESSION":r.blockHeight=1,r.uncompress=le;break;case"ZIP_COMPRESSION":r.blockHeight=16,r.uncompress=le;break;case"PIZ_COMPRESSION":r.blockHeight=32,r.uncompress=Ye;break;case"PXR24_COMPRESSION":r.blockHeight=16,r.uncompress=We;break;case"DWAA_COMPRESSION":r.blockHeight=32,r.uncompress=fe;break;case"DWAB_COMPRESSION":r.blockHeight=256,r.uncompress=fe;break;default:throw new Error("EXRLoader.parse: "+e.compression+" is unsupported")}const i={};for(const s of e.channels)switch(s.name){case"Y":case"R":case"G":case"B":case"A":i[s.name]=!0,r.type=s.pixelType}let a=!1;if(i.R&&i.G&&i.B)a=!i.A,r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(i.Y)r.outputChannels=1,r.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(r.type==1)switch(l){case se:r.getter=$e;break;case Q:r.getter=K;break}else if(r.type==2)switch(l){case se:r.getter=T;break;case Q:r.getter=qe}else throw new Error("EXRLoader.parse: unsupported pixelType "+r.type+" for "+e.compression+".");r.columns=r.width;const u=r.width*r.height*r.outputChannels;switch(l){case se:r.byteArray=new Float32Array(u),a&&r.byteArray.fill(1,0,u);break;case Q:r.byteArray=new Uint16Array(u),a&&r.byteArray.fill(15360,0,u);break;default:console.error("THREE.EXRLoader: unsupported type: ",l);break}let c=0;for(const s of e.channels)r.decodeChannels[s.name]!==void 0&&(r.channelByteOffsets[s.name]=c),c+=s.pixelType*2;if(r.totalBytes=c,r.outLineWidth=r.width*r.outputChannels,e.lineOrder==="INCREASING_Y"?r.scanOrder=s=>s:r.scanOrder=s=>r.height-1-s,r.outputChannels==4?(r.format=wn,r.colorSpace=ve):(r.format=mn,r.colorSpace=In),e.spec.singleTile){r.blockHeight=e.tiles.ySize,r.blockWidth=e.tiles.xSize;const s=cn(e.tiles,r.width,r.height),h=ye(s,r.width,e.tiles.xSize,e.tiles.roundingMode),w=ye(s,r.height,e.tiles.ySize,e.tiles.roundingMode);r.tileCount=h[0]*w[0];for(let p=0;p<s;p++)for(let I=0;I<w[p];I++)for(let E=0;E<h[p];E++)b(n,o);r.decode=un.bind(r)}else{r.blockWidth=r.width;const s=Math.ceil(r.height/r.blockHeight);for(let h=0;h<s;h++)b(n,o);r.decode=an.bind(r)}return r}const Ce={value:0},_e=new DataView(k),En=new Uint8Array(k),z=hn(_e,k,Ce),G=pn(z,_e,En,Ce,this.type);return G.decode(),{header:z,width:G.width,height:G.height,data:G.byteArray,format:G.format,colorSpace:G.colorSpace,type:this.type}}setDataType(k){return this.type=k,this}load(k,j,ce,ie){function ue(H,ee){H.colorSpace=ee.colorSpace,H.minFilter=Ue,H.magFilter=Ue,H.generateMipmaps=!1,H.flipY=!1,j&&j(H,ee)}return super.load(k,ue,ce,ie)}}export{Bn as EXRLoader};
