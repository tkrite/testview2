import{C as h}from"./ddd@DwDq534T.js";class b{constructor(){this.file_mapper=new Map,this._build_file_("/"),this.debug=!1}_build_file_(e,i=null){e=this._resolve_path_(e),this.file_mapper.set(e,{is_directory:i==null,file_path:e,date:Date.now(),buffer:i,__tmp_children__:[]}),this.debug&&console.info("MK:",e)}list(e,i=!1){if(e=this._resolve_path_(e),this.debug&&console.log("list",e),!this.exists(e))return[];const r=this.file_mapper.get(e);function n(t,o=[]){for(const s of t.__tmp_children__)o.push(s)}if(i){if(r.is_directory){let t=[];return n(r,t),console.log(e,t),t}}else if(r.is_directory){let t=[];for(const o of r.__tmp_children__)t.push(o);return console.log(this.file_mapper),console.log(e,t),t}return r.is_directory?[]:(console.log(e,[r]),[r])}copy(e,i){throw new Error("Not implemented yet.")}move(e,i){throw new Error("Not implemented yet.")}remove(e,i=!1){if(e=this._resolve_path_(e),!this.exists(e))throw new Error("Does not exist. "+e);if(i)this.rmdir(e,!0);else{if(this._is_dir_(e))throw new Error(`${e} is a directory.`);this.file_mapper.delete(e)}this._rebuild_tree_()}rmdir(e,i=!1){if(e=this._resolve_path_(e),!this.exists(e))throw new Error("Does not exist. "+e);if(!this._is_dir_(e))throw new Error(`${e} is a file.`);const r=[];for(const[n,t]of this.file_mapper)n.indexOf(e)===0&&r.push(n);for(const n of r)this.file_mapper.delete(n);this._rebuild_tree_()}mkdir(e,i=!0){if(e=this._resolve_path_(e),console.log("MKDIR:",e),this.exists(e)){if(i)return;throw new Error("Already exists."+e)}this._build_file_(e),this._rebuild_tree_()}read(e){if(e=this._resolve_path_(e),!this.exists(e))throw new Error("Does not exist. "+e);if(this._is_dir_(e))throw new Error(`${e} is a directory.`);return new Uint8Array(this.file_mapper.get(e).buffer)}write(e,i){e=this._resolve_path_(e),console.log("PUT:",e);const r=h.to_array_buffer(i);this._build_file_(e,r),this._rebuild_tree_()}_is_dir_(e){return e=this._resolve_path_(e),e==="/"?!0:this.file_mapper.get(e)?.is_directory}_is_file_(e){e=this._resolve_path_(e);const i=this.file_mapper.get(e);return i?i.is_directory===!1:!1}exists(e){return e=this._resolve_path_(e),e=="/"?!0:(e[e.length-1]==="/"&&(e=e.slice(0,e.length-1)),this.file_mapper.has(e))}_resolve_path_(e){for(;e.indexOf("//")>=0;)e=e.replace(/\/\//g,"/");let i="http://a.a";e[0]!=="/"&&(i+="/");let r=decodeURI(new URL(encodeURI(i+e)).pathname);return r.length>1&&r[r.length-1]==="/"&&(r=r.slice(0,r.length-1)),r[0]=="/"&&(r=r.slice(1,r.length)),r}_rebuild_tree_(){for(const[e,i]of this.file_mapper)i.__tmp_children__=[];for(const[e,i]of this.file_mapper)if(!(e==="/"||e.length===0)){const r=this._resolve_path_(e+"/../");this.file_mapper.has(r)==!1&&this._build_file_(r),this.file_mapper.get(r).__tmp_children__.push(i)}}}async function v(){}async function x(c={}){return Object.assign({},c),new Promise((i,r)=>{async function n(t,o=3){if(o<=0){t("Could not login.");return}t(null,new b)}n((t,o)=>{t?r(t):i({driver:"memory",async resolve(s){return s},async list(s,l={}){const u={recursive:!1,callback:null};Object.assign(u,l);const a=o.list(s,u.recursive),d=[];for(const _ of a){const m=o._resolve_path_(s),f=h.DPath(_.file_path),y=_.file_path.slice(m.length,_.file_path.length),g=_.file_path;let p={id:_.file_path,protocol:"memory",prefix:"",basename:f.basename,relative_path:y,absolute_path:g,ext:f.ext,is_file:!_.is_directory,is_directory:_.is_directory,date:_.date,date_promise:null};d.push(p)}return d},async put(s,l){return o.write(s,l)},async copy(s,l){return o.copy(s,l)},async move(s,l){return o.move(s,l)},async exists(s){return o.exists(s)},async mkdir(s,l=!1){return o.mkdir(s,l)},async get(s){return o.read(s)},async remove(s,l=!1){return o.remove(s,l)}})})})}export{x as create_memfs_io,v as test};
